[2025-07-06T00:00:1882Z] (neutral) verifySpeaker] error:', err.toString()); }); process.on('close', () => { try { const result = JSON.parse(output.trim()); resolve(result.verified || false); } catch (err) { console.error('[SpeechBrain:verifySpeaker] parse error:', err); resolve(false); } }); }); } export function analyzeEmotion(data) { return new Promise((resolve) => { const process = spawn('python3', [PY_SCRIPT, data, REF_SAMPLE_PATH]); let output = ''; process.stdout.on('data', (chunk) => { output += chunk.toString(); }); process.stderr.on('data', (err) => { console.error('[SpeechBrain:analyzeEmotion] error:', err.toString()); }); process.on('close', () => { try { const result = JSON.parse(output.trim()); resolve(result.emotion || 'neutral'); } catch (err) { console.error('[SpeechBrain:analyzeEmotion] parse error:', err); resolve('neutral'); } }); }); } [#// utils/speechbrain.js import { spawn } from 'child_process'; import path from 'path'; const py_script = path.resolve('scripts/speechbrain-core.py'); const ref_sample_path = path.resolve('voice/reference.wav'); export function verifyspeaker(data) { return new promise((resolve) => { const process = spawn('python3', [py_script, data, ref_sample_path]); let output = ''; process.stdout.on('data', (chunk) => { output += chunk.tostring(); }); process.stderr.on('data', (err) => { console.error('[speechbrain #seg-1883]
[2025-07-06T00:00:1888Z] (neutral) ${task}] Audio file not found:`, audioFilePath); return resolve(task === 'verify' ? false : 'neutral'); } const process = spawn(PYTHON, [SCRIPT_PATH, audioFilePath, REF_SAMPLE_PATH]); let output = ''; process.stdout.on('data', (chunk) => { output += chunk.toString(); }); process.stderr.on('data', (err) => { console.error(`[SpeechBrain:${task}] stderr:`, err.toString()); }); process.on('close', () => { try { const parsed = JSON.parse(output.trim()); if (task === 'verify') { resolve(!!parsed.verified); } else if (task === 'emotion') { resolve(parsed.emotion || 'neutral'); } else { resolve(null); } } catch (err) { console.error(`[SpeechBrain:${task}] JSON parse error:`, err); resolve(task === 'verify' ? false : 'neutral'); } }); }); } export async function verifySpeaker(audioPath) { return runSpeechbrainTask('verify', audioPath); } export async function analyzeEmotion(audioPath) { return runSpeechbrainTask('emotion', audioPath); } [#// utils/speechbrain.js import { spawn } from 'child_process'; import path from 'path'; import fs from 'fs'; const python = 'python3'; const script_path = path.resolve('scripts/speechbrain-core.py'); const ref_sample_path = path.resolve('voice/reference.wav'); function runspeechbraintask(task, audiofilepath) { return new promise((resolve) => { if (!fs.existssync(audiofilepath)) { console.error(`[speechbrain #seg-1889]
[2025-07-06T00:00:1882Z] (neutral) verifySpeaker] error:', err.toString()); }); process.on('close', () => { try { const result = JSON.parse(output.trim()); resolve(result.verified || false); } catch (err) { console.error('[SpeechBrain:verifySpeaker] parse error:', err); resolve(false); } }); }); } export function analyzeEmotion(data) { return new Promise((resolve) => { const process = spawn('python3', [PY_SCRIPT, data, REF_SAMPLE_PATH]); let output = ''; process.stdout.on('data', (chunk) => { output += chunk.toString(); }); process.stderr.on('data', (err) => { console.error('[SpeechBrain:analyzeEmotion] error:', err.toString()); }); process.on('close', () => { try { const result = JSON.parse(output.trim()); resolve(result.emotion || 'neutral'); } catch (err) { console.error('[SpeechBrain:analyzeEmotion] parse error:', err); resolve('neutral'); } }); }); } [#// utils/speechbrain.js import { spawn } from 'child_process'; import path from 'path'; const py_script = path.resolve('scripts/speechbrain-core.py'); const ref_sample_path = path.resolve('voice/reference.wav'); export function verifyspeaker(data) { return new promise((resolve) => { const process = spawn('python3', [py_script, data, ref_sample_path]); let output = ''; process.stdout.on('data', (chunk) => { output += chunk.tostring(); }); process.stderr.on('data', (err) => { console.error('[speechbrain #seg-1883]
[2025-07-06T00:00:1888Z] (neutral) ${task}] Audio file not found:`, audioFilePath); return resolve(task === 'verify' ? false : 'neutral'); } const process = spawn(PYTHON, [SCRIPT_PATH, audioFilePath, REF_SAMPLE_PATH]); let output = ''; process.stdout.on('data', (chunk) => { output += chunk.toString(); }); process.stderr.on('data', (err) => { console.error(`[SpeechBrain:${task}] stderr:`, err.toString()); }); process.on('close', () => { try { const parsed = JSON.parse(output.trim()); if (task === 'verify') { resolve(!!parsed.verified); } else if (task === 'emotion') { resolve(parsed.emotion || 'neutral'); } else { resolve(null); } } catch (err) { console.error(`[SpeechBrain:${task}] JSON parse error:`, err); resolve(task === 'verify' ? false : 'neutral'); } }); }); } export async function verifySpeaker(audioPath) { return runSpeechbrainTask('verify', audioPath); } export async function analyzeEmotion(audioPath) { return runSpeechbrainTask('emotion', audioPath); } [#// utils/speechbrain.js import { spawn } from 'child_process'; import path from 'path'; import fs from 'fs'; const python = 'python3'; const script_path = path.resolve('scripts/speechbrain-core.py'); const ref_sample_path = path.resolve('voice/reference.wav'); function runspeechbraintask(task, audiofilepath) { return new promise((resolve) => { if (!fs.existssync(audiofilepath)) { console.error(`[speechbrain #seg-1889]
