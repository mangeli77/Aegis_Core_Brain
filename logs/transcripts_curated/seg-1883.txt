[2025-07-06T00:00:1882Z] (neutral) ?Êutils/speechbrain.js [#system #seg-1883]
[2025-07-06T00:00:1882Z] (neutral) ?Êutils/speechbrain.js [#system #seg-1883]
[2025-07-06T00:00:1882Z] (neutral) verifySpeaker] error:', err.toString()); }); process.on('close', () => { try { const result = JSON.parse(output.trim()); resolve(result.verified || false); } catch (err) { console.error('[SpeechBrain:verifySpeaker] parse error:', err); resolve(false); } }); }); } export function analyzeEmotion(data) { return new Promise((resolve) => { const process = spawn('python3', [PY_SCRIPT, data, REF_SAMPLE_PATH]); let output = ''; process.stdout.on('data', (chunk) => { output += chunk.toString(); }); process.stderr.on('data', (err) => { console.error('[SpeechBrain:analyzeEmotion] error:', err.toString()); }); process.on('close', () => { try { const result = JSON.parse(output.trim()); resolve(result.emotion || 'neutral'); } catch (err) { console.error('[SpeechBrain:analyzeEmotion] parse error:', err); resolve('neutral'); } }); }); } [#// utils/speechbrain.js import { spawn } from 'child_process'; import path from 'path'; const py_script = path.resolve('scripts/speechbrain-core.py'); const ref_sample_path = path.resolve('voice/reference.wav'); export function verifyspeaker(data) { return new promise((resolve) => { const process = spawn('python3', [py_script, data, ref_sample_path]); let output = ''; process.stdout.on('data', (chunk) => { output += chunk.tostring(); }); process.stderr.on('data', (err) => { console.error('[speechbrain #seg-1883]
[2025-07-06T00:00:1882Z] (neutral) ?Êutils/speechbrain.js [#system #seg-1883]
[2025-07-06T00:00:1882Z] (neutral) verifySpeaker] error:', err.toString()); }); process.on('close', () => { try { const result = JSON.parse(output.trim()); resolve(result.verified || false); } catch (err) { console.error('[SpeechBrain:verifySpeaker] parse error:', err); resolve(false); } }); }); } export function analyzeEmotion(data) { return new Promise((resolve) => { const process = spawn('python3', [PY_SCRIPT, data, REF_SAMPLE_PATH]); let output = ''; process.stdout.on('data', (chunk) => { output += chunk.toString(); }); process.stderr.on('data', (err) => { console.error('[SpeechBrain:analyzeEmotion] error:', err.toString()); }); process.on('close', () => { try { const result = JSON.parse(output.trim()); resolve(result.emotion || 'neutral'); } catch (err) { console.error('[SpeechBrain:analyzeEmotion] parse error:', err); resolve('neutral'); } }); }); } [#// utils/speechbrain.js import { spawn } from 'child_process'; import path from 'path'; const py_script = path.resolve('scripts/speechbrain-core.py'); const ref_sample_path = path.resolve('voice/reference.wav'); export function verifyspeaker(data) { return new promise((resolve) => { const process = spawn('python3', [py_script, data, ref_sample_path]); let output = ''; process.stdout.on('data', (chunk) => { output += chunk.tostring(); }); process.stderr.on('data', (err) => { console.error('[speechbrain #seg-1883]
